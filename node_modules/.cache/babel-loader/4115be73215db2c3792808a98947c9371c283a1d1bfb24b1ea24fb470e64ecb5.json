{"ast":null,"code":"function _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\nfunction createCancelError(cause) {\n  return new Error('Cancelled', {\n    cause\n  });\n}\nfunction abortOn(signal) {\n  if (signal != null) {\n    var _this$then;\n    const abortPromise = () => this.abort(signal.reason);\n    signal.addEventListener('abort', abortPromise, {\n      once: true\n    });\n    const removeAbortListener = () => {\n      signal.removeEventListener('abort', abortPromise);\n    };\n    (_this$then = this.then) == null || _this$then.call(this, removeAbortListener, removeAbortListener);\n  }\n  return this;\n}\nvar _activeRequests = /*#__PURE__*/_classPrivateFieldLooseKey(\"activeRequests\");\nvar _queuedHandlers = /*#__PURE__*/_classPrivateFieldLooseKey(\"queuedHandlers\");\nvar _paused = /*#__PURE__*/_classPrivateFieldLooseKey(\"paused\");\nvar _pauseTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"pauseTimer\");\nvar _downLimit = /*#__PURE__*/_classPrivateFieldLooseKey(\"downLimit\");\nvar _upperLimit = /*#__PURE__*/_classPrivateFieldLooseKey(\"upperLimit\");\nvar _rateLimitingTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"rateLimitingTimer\");\nvar _call = /*#__PURE__*/_classPrivateFieldLooseKey(\"call\");\nvar _queueNext = /*#__PURE__*/_classPrivateFieldLooseKey(\"queueNext\");\nvar _next = /*#__PURE__*/_classPrivateFieldLooseKey(\"next\");\nvar _queue = /*#__PURE__*/_classPrivateFieldLooseKey(\"queue\");\nvar _dequeue = /*#__PURE__*/_classPrivateFieldLooseKey(\"dequeue\");\nvar _resume = /*#__PURE__*/_classPrivateFieldLooseKey(\"resume\");\nvar _increaseLimit = /*#__PURE__*/_classPrivateFieldLooseKey(\"increaseLimit\");\nexport class RateLimitedQueue {\n  constructor(limit) {\n    Object.defineProperty(this, _dequeue, {\n      value: _dequeue2\n    });\n    Object.defineProperty(this, _queue, {\n      value: _queue2\n    });\n    Object.defineProperty(this, _next, {\n      value: _next2\n    });\n    Object.defineProperty(this, _queueNext, {\n      value: _queueNext2\n    });\n    Object.defineProperty(this, _call, {\n      value: _call2\n    });\n    Object.defineProperty(this, _activeRequests, {\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, _queuedHandlers, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _paused, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _pauseTimer, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _downLimit, {\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, _upperLimit, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _rateLimitingTimer, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _resume, {\n      writable: true,\n      value: () => this.resume()\n    });\n    Object.defineProperty(this, _increaseLimit, {\n      writable: true,\n      value: () => {\n        if (_classPrivateFieldLooseBase(this, _paused)[_paused]) {\n          _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], 0);\n          return;\n        }\n        _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] = this.limit;\n        this.limit = Math.ceil((_classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] + _classPrivateFieldLooseBase(this, _downLimit)[_downLimit]) / 2);\n        for (let i = _classPrivateFieldLooseBase(this, _downLimit)[_downLimit]; i <= this.limit; i++) {\n          _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();\n        }\n        if (_classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] - _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] > 3) {\n          _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], 2000);\n        } else {\n          _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] = Math.floor(_classPrivateFieldLooseBase(this, _downLimit)[_downLimit] / 2);\n        }\n      }\n    });\n    if (typeof limit !== 'number' || limit === 0) {\n      this.limit = Infinity;\n    } else {\n      this.limit = limit;\n    }\n  }\n  run(fn, queueOptions) {\n    if (!_classPrivateFieldLooseBase(this, _paused)[_paused] && _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] < this.limit) {\n      return _classPrivateFieldLooseBase(this, _call)[_call](fn);\n    }\n    return _classPrivateFieldLooseBase(this, _queue)[_queue](fn, queueOptions);\n  }\n  wrapSyncFunction(fn, queueOptions) {\n    var _this = this;\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const queuedRequest = _this.run(() => {\n        fn(...args);\n        queueMicrotask(() => queuedRequest.done());\n        return () => {};\n      }, queueOptions);\n      return {\n        abortOn,\n        abort() {\n          queuedRequest.abort();\n        }\n      };\n    };\n  }\n  wrapPromiseFunction(fn, queueOptions) {\n    var _this2 = this;\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      let queuedRequest;\n      const outerPromise = new Promise((resolve, reject) => {\n        queuedRequest = _this2.run(() => {\n          let cancelError;\n          let innerPromise;\n          try {\n            innerPromise = Promise.resolve(fn(...args));\n          } catch (err) {\n            innerPromise = Promise.reject(err);\n          }\n          innerPromise.then(result => {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              resolve(result);\n            }\n          }, err => {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              reject(err);\n            }\n          });\n          return cause => {\n            cancelError = createCancelError(cause);\n          };\n        }, queueOptions);\n      });\n      outerPromise.abort = cause => {\n        queuedRequest.abort(cause);\n      };\n      outerPromise.abortOn = abortOn;\n      return outerPromise;\n    };\n  }\n  resume() {\n    _classPrivateFieldLooseBase(this, _paused)[_paused] = false;\n    clearTimeout(_classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer]);\n    for (let i = 0; i < this.limit; i++) {\n      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();\n    }\n  }\n  /**\n   * Freezes the queue for a while or indefinitely.\n   *\n   * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.\n   *                                    If omitted, the queue won't resume automatically.\n   */\n  pause(duration) {\n    if (duration === void 0) {\n      duration = null;\n    }\n    _classPrivateFieldLooseBase(this, _paused)[_paused] = true;\n    clearTimeout(_classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer]);\n    if (duration != null) {\n      _classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer] = setTimeout(_classPrivateFieldLooseBase(this, _resume)[_resume], duration);\n    }\n  }\n\n  /**\n   * Pauses the queue for a duration, and lower the limit of concurrent requests\n   * when the queue resumes. When the queue resumes, it tries to progressively\n   * increase the limit in `this.#increaseLimit` until another call is made to\n   * `this.rateLimit`.\n   * Call this function when using the RateLimitedQueue for network requests and\n   * the remote server responds with 429 HTTP code.\n   *\n   * @param {number} duration in milliseconds.\n   */\n  rateLimit(duration) {\n    clearTimeout(_classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer]);\n    this.pause(duration);\n    if (this.limit > 1 && Number.isFinite(this.limit)) {\n      _classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] = this.limit - 1;\n      this.limit = _classPrivateFieldLooseBase(this, _downLimit)[_downLimit];\n      _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], duration);\n    }\n  }\n  get isPaused() {\n    return _classPrivateFieldLooseBase(this, _paused)[_paused];\n  }\n}\nfunction _call2(fn) {\n  _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] += 1;\n  let done = false;\n  let cancelActive;\n  try {\n    cancelActive = fn();\n  } catch (err) {\n    _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;\n    throw err;\n  }\n  return {\n    abort: cause => {\n      if (done) return;\n      done = true;\n      _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;\n      cancelActive == null || cancelActive(cause);\n      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();\n    },\n    done: () => {\n      if (done) return;\n      done = true;\n      _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;\n      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();\n    }\n  };\n}\nfunction _queueNext2() {\n  // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n  // one by one without continuously _advancing_ it (and starting new tasks before immediately\n  // aborting them)\n  queueMicrotask(() => _classPrivateFieldLooseBase(this, _next)[_next]());\n}\nfunction _next2() {\n  if (_classPrivateFieldLooseBase(this, _paused)[_paused] || _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] >= this.limit) {\n    return;\n  }\n  if (_classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].length === 0) {\n    return;\n  }\n\n  // Dispatch the next request, and update the abort/done handlers\n  // so that cancelling it does the Right Thing (and doesn't just try\n  // to dequeue an already-running request).\n  const next = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].shift();\n  if (next == null) {\n    throw new Error('Invariant violation: next is null');\n  }\n  const handler = _classPrivateFieldLooseBase(this, _call)[_call](next.fn);\n  next.abort = handler.abort;\n  next.done = handler.done;\n}\nfunction _queue2(fn, options) {\n  const handler = {\n    fn,\n    priority: (options == null ? void 0 : options.priority) || 0,\n    abort: () => {\n      _classPrivateFieldLooseBase(this, _dequeue)[_dequeue](handler);\n    },\n    done: () => {\n      throw new Error('Cannot mark a queued request as done: this indicates a bug');\n    }\n  };\n  const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].findIndex(other => {\n    return handler.priority > other.priority;\n  });\n  if (index === -1) {\n    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].push(handler);\n  } else {\n    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 0, handler);\n  }\n  return handler;\n}\nfunction _dequeue2(handler) {\n  const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].indexOf(handler);\n  if (index !== -1) {\n    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 1);\n  }\n}\nexport const internalRateLimitedQueue = Symbol('__queue');","map":{"version":3,"names":["_classPrivateFieldLooseBase","receiver","privateKey","Object","prototype","hasOwnProperty","call","TypeError","id","_classPrivateFieldLooseKey","name","createCancelError","cause","Error","abortOn","signal","_this$then","abortPromise","abort","reason","addEventListener","once","removeAbortListener","removeEventListener","then","_activeRequests","_queuedHandlers","_paused","_pauseTimer","_downLimit","_upperLimit","_rateLimitingTimer","_call","_queueNext","_next","_queue","_dequeue","_resume","_increaseLimit","RateLimitedQueue","constructor","limit","defineProperty","value","_dequeue2","_queue2","_next2","_queueNext2","_call2","writable","resume","setTimeout","Math","ceil","i","floor","Infinity","run","fn","queueOptions","wrapSyncFunction","_this","_len","arguments","length","args","Array","_key","queuedRequest","queueMicrotask","done","wrapPromiseFunction","_this2","_len2","_key2","outerPromise","Promise","resolve","reject","cancelError","innerPromise","err","result","clearTimeout","pause","duration","rateLimit","Number","isFinite","isPaused","cancelActive","next","shift","handler","options","priority","index","findIndex","other","push","splice","indexOf","internalRateLimitedQueue","Symbol"],"sources":["/home/nainar/Documents/reactProjects/userAuthentiCator/registeration-login/node_modules/@uppy/utils/lib/RateLimitedQueue.js"],"sourcesContent":["function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError(\"attempted to use private field on non-instance\"); } return receiver; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) { return \"__private_\" + id++ + \"_\" + name; }\nfunction createCancelError(cause) {\n  return new Error('Cancelled', {\n    cause\n  });\n}\nfunction abortOn(signal) {\n  if (signal != null) {\n    var _this$then;\n    const abortPromise = () => this.abort(signal.reason);\n    signal.addEventListener('abort', abortPromise, {\n      once: true\n    });\n    const removeAbortListener = () => {\n      signal.removeEventListener('abort', abortPromise);\n    };\n    (_this$then = this.then) == null || _this$then.call(this, removeAbortListener, removeAbortListener);\n  }\n  return this;\n}\nvar _activeRequests = /*#__PURE__*/_classPrivateFieldLooseKey(\"activeRequests\");\nvar _queuedHandlers = /*#__PURE__*/_classPrivateFieldLooseKey(\"queuedHandlers\");\nvar _paused = /*#__PURE__*/_classPrivateFieldLooseKey(\"paused\");\nvar _pauseTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"pauseTimer\");\nvar _downLimit = /*#__PURE__*/_classPrivateFieldLooseKey(\"downLimit\");\nvar _upperLimit = /*#__PURE__*/_classPrivateFieldLooseKey(\"upperLimit\");\nvar _rateLimitingTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"rateLimitingTimer\");\nvar _call = /*#__PURE__*/_classPrivateFieldLooseKey(\"call\");\nvar _queueNext = /*#__PURE__*/_classPrivateFieldLooseKey(\"queueNext\");\nvar _next = /*#__PURE__*/_classPrivateFieldLooseKey(\"next\");\nvar _queue = /*#__PURE__*/_classPrivateFieldLooseKey(\"queue\");\nvar _dequeue = /*#__PURE__*/_classPrivateFieldLooseKey(\"dequeue\");\nvar _resume = /*#__PURE__*/_classPrivateFieldLooseKey(\"resume\");\nvar _increaseLimit = /*#__PURE__*/_classPrivateFieldLooseKey(\"increaseLimit\");\nexport class RateLimitedQueue {\n  constructor(limit) {\n    Object.defineProperty(this, _dequeue, {\n      value: _dequeue2\n    });\n    Object.defineProperty(this, _queue, {\n      value: _queue2\n    });\n    Object.defineProperty(this, _next, {\n      value: _next2\n    });\n    Object.defineProperty(this, _queueNext, {\n      value: _queueNext2\n    });\n    Object.defineProperty(this, _call, {\n      value: _call2\n    });\n    Object.defineProperty(this, _activeRequests, {\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, _queuedHandlers, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _paused, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _pauseTimer, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _downLimit, {\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(this, _upperLimit, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _rateLimitingTimer, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _resume, {\n      writable: true,\n      value: () => this.resume()\n    });\n    Object.defineProperty(this, _increaseLimit, {\n      writable: true,\n      value: () => {\n        if (_classPrivateFieldLooseBase(this, _paused)[_paused]) {\n          _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], 0);\n          return;\n        }\n        _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] = this.limit;\n        this.limit = Math.ceil((_classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] + _classPrivateFieldLooseBase(this, _downLimit)[_downLimit]) / 2);\n        for (let i = _classPrivateFieldLooseBase(this, _downLimit)[_downLimit]; i <= this.limit; i++) {\n          _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();\n        }\n        if (_classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] - _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] > 3) {\n          _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], 2000);\n        } else {\n          _classPrivateFieldLooseBase(this, _downLimit)[_downLimit] = Math.floor(_classPrivateFieldLooseBase(this, _downLimit)[_downLimit] / 2);\n        }\n      }\n    });\n    if (typeof limit !== 'number' || limit === 0) {\n      this.limit = Infinity;\n    } else {\n      this.limit = limit;\n    }\n  }\n  run(fn, queueOptions) {\n    if (!_classPrivateFieldLooseBase(this, _paused)[_paused] && _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] < this.limit) {\n      return _classPrivateFieldLooseBase(this, _call)[_call](fn);\n    }\n    return _classPrivateFieldLooseBase(this, _queue)[_queue](fn, queueOptions);\n  }\n  wrapSyncFunction(fn, queueOptions) {\n    var _this = this;\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const queuedRequest = _this.run(() => {\n        fn(...args);\n        queueMicrotask(() => queuedRequest.done());\n        return () => {};\n      }, queueOptions);\n      return {\n        abortOn,\n        abort() {\n          queuedRequest.abort();\n        }\n      };\n    };\n  }\n  wrapPromiseFunction(fn, queueOptions) {\n    var _this2 = this;\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      let queuedRequest;\n      const outerPromise = new Promise((resolve, reject) => {\n        queuedRequest = _this2.run(() => {\n          let cancelError;\n          let innerPromise;\n          try {\n            innerPromise = Promise.resolve(fn(...args));\n          } catch (err) {\n            innerPromise = Promise.reject(err);\n          }\n          innerPromise.then(result => {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              resolve(result);\n            }\n          }, err => {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              reject(err);\n            }\n          });\n          return cause => {\n            cancelError = createCancelError(cause);\n          };\n        }, queueOptions);\n      });\n      outerPromise.abort = cause => {\n        queuedRequest.abort(cause);\n      };\n      outerPromise.abortOn = abortOn;\n      return outerPromise;\n    };\n  }\n  resume() {\n    _classPrivateFieldLooseBase(this, _paused)[_paused] = false;\n    clearTimeout(_classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer]);\n    for (let i = 0; i < this.limit; i++) {\n      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();\n    }\n  }\n  /**\n   * Freezes the queue for a while or indefinitely.\n   *\n   * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.\n   *                                    If omitted, the queue won't resume automatically.\n   */\n  pause(duration) {\n    if (duration === void 0) {\n      duration = null;\n    }\n    _classPrivateFieldLooseBase(this, _paused)[_paused] = true;\n    clearTimeout(_classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer]);\n    if (duration != null) {\n      _classPrivateFieldLooseBase(this, _pauseTimer)[_pauseTimer] = setTimeout(_classPrivateFieldLooseBase(this, _resume)[_resume], duration);\n    }\n  }\n\n  /**\n   * Pauses the queue for a duration, and lower the limit of concurrent requests\n   * when the queue resumes. When the queue resumes, it tries to progressively\n   * increase the limit in `this.#increaseLimit` until another call is made to\n   * `this.rateLimit`.\n   * Call this function when using the RateLimitedQueue for network requests and\n   * the remote server responds with 429 HTTP code.\n   *\n   * @param {number} duration in milliseconds.\n   */\n  rateLimit(duration) {\n    clearTimeout(_classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer]);\n    this.pause(duration);\n    if (this.limit > 1 && Number.isFinite(this.limit)) {\n      _classPrivateFieldLooseBase(this, _upperLimit)[_upperLimit] = this.limit - 1;\n      this.limit = _classPrivateFieldLooseBase(this, _downLimit)[_downLimit];\n      _classPrivateFieldLooseBase(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase(this, _increaseLimit)[_increaseLimit], duration);\n    }\n  }\n  get isPaused() {\n    return _classPrivateFieldLooseBase(this, _paused)[_paused];\n  }\n}\nfunction _call2(fn) {\n  _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] += 1;\n  let done = false;\n  let cancelActive;\n  try {\n    cancelActive = fn();\n  } catch (err) {\n    _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;\n    throw err;\n  }\n  return {\n    abort: cause => {\n      if (done) return;\n      done = true;\n      _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;\n      cancelActive == null || cancelActive(cause);\n      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();\n    },\n    done: () => {\n      if (done) return;\n      done = true;\n      _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;\n      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();\n    }\n  };\n}\nfunction _queueNext2() {\n  // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n  // one by one without continuously _advancing_ it (and starting new tasks before immediately\n  // aborting them)\n  queueMicrotask(() => _classPrivateFieldLooseBase(this, _next)[_next]());\n}\nfunction _next2() {\n  if (_classPrivateFieldLooseBase(this, _paused)[_paused] || _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] >= this.limit) {\n    return;\n  }\n  if (_classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].length === 0) {\n    return;\n  }\n\n  // Dispatch the next request, and update the abort/done handlers\n  // so that cancelling it does the Right Thing (and doesn't just try\n  // to dequeue an already-running request).\n  const next = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].shift();\n  if (next == null) {\n    throw new Error('Invariant violation: next is null');\n  }\n  const handler = _classPrivateFieldLooseBase(this, _call)[_call](next.fn);\n  next.abort = handler.abort;\n  next.done = handler.done;\n}\nfunction _queue2(fn, options) {\n  const handler = {\n    fn,\n    priority: (options == null ? void 0 : options.priority) || 0,\n    abort: () => {\n      _classPrivateFieldLooseBase(this, _dequeue)[_dequeue](handler);\n    },\n    done: () => {\n      throw new Error('Cannot mark a queued request as done: this indicates a bug');\n    }\n  };\n  const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].findIndex(other => {\n    return handler.priority > other.priority;\n  });\n  if (index === -1) {\n    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].push(handler);\n  } else {\n    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 0, handler);\n  }\n  return handler;\n}\nfunction _dequeue2(handler) {\n  const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].indexOf(handler);\n  if (index !== -1) {\n    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 1);\n  }\n}\nexport const internalRateLimitedQueue = Symbol('__queue');"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}