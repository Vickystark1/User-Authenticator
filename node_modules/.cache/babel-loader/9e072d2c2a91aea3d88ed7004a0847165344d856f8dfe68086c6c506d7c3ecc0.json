{"ast":null,"code":"import getFileType from \"./getFileType.js\";\nfunction encodeCharacter(character) {\n  return character.charCodeAt(0).toString(32);\n}\nfunction encodeFilename(name) {\n  let suffix = '';\n  return name.replace(/[^A-Z0-9]/gi, character => {\n    suffix += `-${encodeCharacter(character)}`;\n    return '/';\n  }) + suffix;\n}\n\n/**\n * Takes a file object and turns it into fileID, by converting file.name to lowercase,\n * removing extra characters and adding type, size and lastModified\n */\nexport default function generateFileID(file) {\n  // It's tempting to do `[items].filter(Boolean).join('-')` here, but that\n  // is slower! simple string concatenation is fast\n\n  let id = 'uppy';\n  if (typeof file.name === 'string') {\n    id += `-${encodeFilename(file.name.toLowerCase())}`;\n  }\n  if (file.type !== undefined) {\n    id += `-${file.type}`;\n  }\n  if (file.meta && typeof file.meta.relativePath === 'string') {\n    id += `-${encodeFilename(file.meta.relativePath.toLowerCase())}`;\n  }\n  if (file.data.size !== undefined) {\n    id += `-${file.data.size}`;\n  }\n  if (file.data.lastModified !== undefined) {\n    id += `-${file.data.lastModified}`;\n  }\n  return id;\n}\n\n// If the provider has a stable, unique ID, then we can use that to identify the file.\n// Then we don't have to generate our own ID, and we can add the same file many times if needed (different path)\nfunction hasFileStableId(file) {\n  if (!file.isRemote || !file.remote) return false;\n  // These are the providers that it seems like have stable IDs for their files. The other's I haven't checked yet.\n  const stableIdProviders = new Set(['box', 'dropbox', 'drive', 'facebook', 'unsplash']);\n  return stableIdProviders.has(file.remote.provider);\n}\nexport function getSafeFileId(file) {\n  if (hasFileStableId(file)) return file.id;\n  const fileType = getFileType(file);\n  return generateFileID({\n    ...file,\n    type: fileType\n  });\n}","map":{"version":3,"names":["getFileType","encodeCharacter","character","charCodeAt","toString","encodeFilename","name","suffix","replace","generateFileID","file","id","toLowerCase","type","undefined","meta","relativePath","data","size","lastModified","hasFileStableId","isRemote","remote","stableIdProviders","Set","has","provider","getSafeFileId","fileType"],"sources":["/home/nainar/Documents/reactProjects/userAuthentiCator/registeration-login/node_modules/@uppy/utils/lib/generateFileID.js"],"sourcesContent":["import getFileType from \"./getFileType.js\";\nfunction encodeCharacter(character) {\n  return character.charCodeAt(0).toString(32);\n}\nfunction encodeFilename(name) {\n  let suffix = '';\n  return name.replace(/[^A-Z0-9]/gi, character => {\n    suffix += `-${encodeCharacter(character)}`;\n    return '/';\n  }) + suffix;\n}\n\n/**\n * Takes a file object and turns it into fileID, by converting file.name to lowercase,\n * removing extra characters and adding type, size and lastModified\n */\nexport default function generateFileID(file) {\n  // It's tempting to do `[items].filter(Boolean).join('-')` here, but that\n  // is slower! simple string concatenation is fast\n\n  let id = 'uppy';\n  if (typeof file.name === 'string') {\n    id += `-${encodeFilename(file.name.toLowerCase())}`;\n  }\n  if (file.type !== undefined) {\n    id += `-${file.type}`;\n  }\n  if (file.meta && typeof file.meta.relativePath === 'string') {\n    id += `-${encodeFilename(file.meta.relativePath.toLowerCase())}`;\n  }\n  if (file.data.size !== undefined) {\n    id += `-${file.data.size}`;\n  }\n  if (file.data.lastModified !== undefined) {\n    id += `-${file.data.lastModified}`;\n  }\n  return id;\n}\n\n// If the provider has a stable, unique ID, then we can use that to identify the file.\n// Then we don't have to generate our own ID, and we can add the same file many times if needed (different path)\nfunction hasFileStableId(file) {\n  if (!file.isRemote || !file.remote) return false;\n  // These are the providers that it seems like have stable IDs for their files. The other's I haven't checked yet.\n  const stableIdProviders = new Set(['box', 'dropbox', 'drive', 'facebook', 'unsplash']);\n  return stableIdProviders.has(file.remote.provider);\n}\nexport function getSafeFileId(file) {\n  if (hasFileStableId(file)) return file.id;\n  const fileType = getFileType(file);\n  return generateFileID({\n    ...file,\n    type: fileType\n  });\n}"],"mappings":"AAAA,OAAOA,WAAW,MAAM,kBAAkB;AAC1C,SAASC,eAAeA,CAACC,SAAS,EAAE;EAClC,OAAOA,SAAS,CAACC,UAAU,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC;AAC7C;AACA,SAASC,cAAcA,CAACC,IAAI,EAAE;EAC5B,IAAIC,MAAM,GAAG,EAAE;EACf,OAAOD,IAAI,CAACE,OAAO,CAAC,aAAa,EAAEN,SAAS,IAAI;IAC9CK,MAAM,IAAK,IAAGN,eAAe,CAACC,SAAS,CAAE,EAAC;IAC1C,OAAO,GAAG;EACZ,CAAC,CAAC,GAAGK,MAAM;AACb;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAASE,cAAcA,CAACC,IAAI,EAAE;EAC3C;EACA;;EAEA,IAAIC,EAAE,GAAG,MAAM;EACf,IAAI,OAAOD,IAAI,CAACJ,IAAI,KAAK,QAAQ,EAAE;IACjCK,EAAE,IAAK,IAAGN,cAAc,CAACK,IAAI,CAACJ,IAAI,CAACM,WAAW,CAAC,CAAC,CAAE,EAAC;EACrD;EACA,IAAIF,IAAI,CAACG,IAAI,KAAKC,SAAS,EAAE;IAC3BH,EAAE,IAAK,IAAGD,IAAI,CAACG,IAAK,EAAC;EACvB;EACA,IAAIH,IAAI,CAACK,IAAI,IAAI,OAAOL,IAAI,CAACK,IAAI,CAACC,YAAY,KAAK,QAAQ,EAAE;IAC3DL,EAAE,IAAK,IAAGN,cAAc,CAACK,IAAI,CAACK,IAAI,CAACC,YAAY,CAACJ,WAAW,CAAC,CAAC,CAAE,EAAC;EAClE;EACA,IAAIF,IAAI,CAACO,IAAI,CAACC,IAAI,KAAKJ,SAAS,EAAE;IAChCH,EAAE,IAAK,IAAGD,IAAI,CAACO,IAAI,CAACC,IAAK,EAAC;EAC5B;EACA,IAAIR,IAAI,CAACO,IAAI,CAACE,YAAY,KAAKL,SAAS,EAAE;IACxCH,EAAE,IAAK,IAAGD,IAAI,CAACO,IAAI,CAACE,YAAa,EAAC;EACpC;EACA,OAAOR,EAAE;AACX;;AAEA;AACA;AACA,SAASS,eAAeA,CAACV,IAAI,EAAE;EAC7B,IAAI,CAACA,IAAI,CAACW,QAAQ,IAAI,CAACX,IAAI,CAACY,MAAM,EAAE,OAAO,KAAK;EAChD;EACA,MAAMC,iBAAiB,GAAG,IAAIC,GAAG,CAAC,CAAC,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;EACtF,OAAOD,iBAAiB,CAACE,GAAG,CAACf,IAAI,CAACY,MAAM,CAACI,QAAQ,CAAC;AACpD;AACA,OAAO,SAASC,aAAaA,CAACjB,IAAI,EAAE;EAClC,IAAIU,eAAe,CAACV,IAAI,CAAC,EAAE,OAAOA,IAAI,CAACC,EAAE;EACzC,MAAMiB,QAAQ,GAAG5B,WAAW,CAACU,IAAI,CAAC;EAClC,OAAOD,cAAc,CAAC;IACpB,GAAGC,IAAI;IACPG,IAAI,EAAEe;EACR,CAAC,CAAC;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}