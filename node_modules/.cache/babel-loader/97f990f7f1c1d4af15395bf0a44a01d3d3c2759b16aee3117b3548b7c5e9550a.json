{"ast":null,"code":"function _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\n// We're using a generic because languages have different plural rules.\n\n// eslint-disable-next-line no-use-before-define\n\nfunction insertReplacement(source, rx, replacement) {\n  const newParts = [];\n  source.forEach(chunk => {\n    // When the source contains multiple placeholders for interpolation,\n    // we should ignore chunks that are not strings, because those\n    // can be JSX objects and will be otherwise incorrectly turned into strings.\n    // Without this condition we’d get this: [object Object] hello [object Object] my <button>\n    if (typeof chunk !== 'string') {\n      return newParts.push(chunk);\n    }\n    return rx[Symbol.split](chunk).forEach((raw, i, list) => {\n      if (raw !== '') {\n        newParts.push(raw);\n      }\n\n      // Interlace with the `replacement` value\n      if (i < list.length - 1) {\n        newParts.push(replacement);\n      }\n    });\n  });\n  return newParts;\n}\n\n/**\n * Takes a string with placeholder variables like `%{smart_count} file selected`\n * and replaces it with values from options `{smart_count: 5}`\n *\n * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE\n * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299\n *\n * @param phrase that needs interpolation, with placeholders\n * @param options with values that will be used to replace placeholders\n */\nfunction interpolate(phrase, options) {\n  const dollarRegex = /\\$/g;\n  const dollarBillsYall = '$$$$';\n  let interpolated = [phrase];\n  if (options == null) return interpolated;\n  for (const arg of Object.keys(options)) {\n    if (arg !== '_') {\n      // Ensure replacement value is escaped to prevent special $-prefixed\n      // regex replace tokens. the \"$$$$\" is needed because each \"$\" needs to\n      // be escaped with \"$\" itself, and we need two in the resulting output.\n      let replacement = options[arg];\n      if (typeof replacement === 'string') {\n        replacement = dollarRegex[Symbol.replace](replacement, dollarBillsYall);\n      }\n      // We create a new `RegExp` each time instead of using a more-efficient\n      // string replace so that the same argument can be replaced multiple times\n      // in the same phrase.\n      interpolated = insertReplacement(interpolated, new RegExp(`%\\\\{${arg}\\\\}`, 'g'), replacement);\n    }\n  }\n  return interpolated;\n}\nconst defaultOnMissingKey = key => {\n  throw new Error(`missing string: ${key}`);\n};\n\n/**\n * Translates strings with interpolation & pluralization support.\n * Extensible with custom dictionaries and pluralization functions.\n *\n * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,\n * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded\n * and can be easily added among with dictionaries, nested objects are used for pluralization\n * as opposed to `||||` delimeter\n *\n * Usage example: `translator.translate('files_chosen', {smart_count: 3})`\n */\nvar _onMissingKey = /*#__PURE__*/_classPrivateFieldLooseKey(\"onMissingKey\");\nvar _apply = /*#__PURE__*/_classPrivateFieldLooseKey(\"apply\");\nexport default class Translator {\n  constructor(locales, _temp) {\n    let {\n      onMissingKey = defaultOnMissingKey\n    } = _temp === void 0 ? {} : _temp;\n    Object.defineProperty(this, _apply, {\n      value: _apply2\n    });\n    Object.defineProperty(this, _onMissingKey, {\n      writable: true,\n      value: void 0\n    });\n    this.locale = {\n      strings: {},\n      pluralize(n) {\n        if (n === 1) {\n          return 0;\n        }\n        return 1;\n      }\n    };\n    if (Array.isArray(locales)) {\n      locales.forEach(_classPrivateFieldLooseBase(this, _apply)[_apply], this);\n    } else {\n      _classPrivateFieldLooseBase(this, _apply)[_apply](locales);\n    }\n    _classPrivateFieldLooseBase(this, _onMissingKey)[_onMissingKey] = onMissingKey;\n  }\n  /**\n   * Public translate method\n   *\n   * @param key\n   * @param options with values that will be used later to replace placeholders in string\n   * @returns string translated (and interpolated)\n   */\n  translate(key, options) {\n    return this.translateArray(key, options).join('');\n  }\n\n  /**\n   * Get a translation and return the translated and interpolated parts as an array.\n   *\n   * @returns The translated and interpolated parts, in order.\n   */\n  translateArray(key, options) {\n    let string = this.locale.strings[key];\n    if (string == null) {\n      _classPrivateFieldLooseBase(this, _onMissingKey)[_onMissingKey](key);\n      string = key;\n    }\n    const hasPluralForms = typeof string === 'object';\n    if (hasPluralForms) {\n      if (options && typeof options.smart_count !== 'undefined') {\n        const plural = this.locale.pluralize(options.smart_count);\n        return interpolate(string[plural], options);\n      }\n      throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}');\n    }\n    if (typeof string !== 'string') {\n      throw new Error(`string was not a string`);\n    }\n    return interpolate(string, options);\n  }\n}\nfunction _apply2(locale) {\n  if (!(locale != null && locale.strings)) {\n    return;\n  }\n  const prevLocale = this.locale;\n  Object.assign(this.locale, {\n    strings: {\n      ...prevLocale.strings,\n      ...locale.strings\n    },\n    pluralize: locale.pluralize || prevLocale.pluralize\n  });\n}","map":{"version":3,"names":["_classPrivateFieldLooseBase","receiver","privateKey","Object","prototype","hasOwnProperty","call","TypeError","id","_classPrivateFieldLooseKey","name","insertReplacement","source","rx","replacement","newParts","forEach","chunk","push","Symbol","split","raw","i","list","length","interpolate","phrase","options","dollarRegex","dollarBillsYall","interpolated","arg","keys","replace","RegExp","defaultOnMissingKey","key","Error","_onMissingKey","_apply","Translator","constructor","locales","_temp","onMissingKey","defineProperty","value","_apply2","writable","locale","strings","pluralize","n","Array","isArray","translate","translateArray","join","string","hasPluralForms","smart_count","plural","prevLocale","assign"],"sources":["/home/nainar/Documents/reactProjects/userAuthentiCator/registeration-login/node_modules/@uppy/utils/lib/Translator.js"],"sourcesContent":["function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError(\"attempted to use private field on non-instance\"); } return receiver; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) { return \"__private_\" + id++ + \"_\" + name; }\n// We're using a generic because languages have different plural rules.\n\n// eslint-disable-next-line no-use-before-define\n\nfunction insertReplacement(source, rx, replacement) {\n  const newParts = [];\n  source.forEach(chunk => {\n    // When the source contains multiple placeholders for interpolation,\n    // we should ignore chunks that are not strings, because those\n    // can be JSX objects and will be otherwise incorrectly turned into strings.\n    // Without this condition we’d get this: [object Object] hello [object Object] my <button>\n    if (typeof chunk !== 'string') {\n      return newParts.push(chunk);\n    }\n    return rx[Symbol.split](chunk).forEach((raw, i, list) => {\n      if (raw !== '') {\n        newParts.push(raw);\n      }\n\n      // Interlace with the `replacement` value\n      if (i < list.length - 1) {\n        newParts.push(replacement);\n      }\n    });\n  });\n  return newParts;\n}\n\n/**\n * Takes a string with placeholder variables like `%{smart_count} file selected`\n * and replaces it with values from options `{smart_count: 5}`\n *\n * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE\n * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299\n *\n * @param phrase that needs interpolation, with placeholders\n * @param options with values that will be used to replace placeholders\n */\nfunction interpolate(phrase, options) {\n  const dollarRegex = /\\$/g;\n  const dollarBillsYall = '$$$$';\n  let interpolated = [phrase];\n  if (options == null) return interpolated;\n  for (const arg of Object.keys(options)) {\n    if (arg !== '_') {\n      // Ensure replacement value is escaped to prevent special $-prefixed\n      // regex replace tokens. the \"$$$$\" is needed because each \"$\" needs to\n      // be escaped with \"$\" itself, and we need two in the resulting output.\n      let replacement = options[arg];\n      if (typeof replacement === 'string') {\n        replacement = dollarRegex[Symbol.replace](replacement, dollarBillsYall);\n      }\n      // We create a new `RegExp` each time instead of using a more-efficient\n      // string replace so that the same argument can be replaced multiple times\n      // in the same phrase.\n      interpolated = insertReplacement(interpolated, new RegExp(`%\\\\{${arg}\\\\}`, 'g'), replacement);\n    }\n  }\n  return interpolated;\n}\nconst defaultOnMissingKey = key => {\n  throw new Error(`missing string: ${key}`);\n};\n\n/**\n * Translates strings with interpolation & pluralization support.\n * Extensible with custom dictionaries and pluralization functions.\n *\n * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,\n * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded\n * and can be easily added among with dictionaries, nested objects are used for pluralization\n * as opposed to `||||` delimeter\n *\n * Usage example: `translator.translate('files_chosen', {smart_count: 3})`\n */\nvar _onMissingKey = /*#__PURE__*/_classPrivateFieldLooseKey(\"onMissingKey\");\nvar _apply = /*#__PURE__*/_classPrivateFieldLooseKey(\"apply\");\nexport default class Translator {\n  constructor(locales, _temp) {\n    let {\n      onMissingKey = defaultOnMissingKey\n    } = _temp === void 0 ? {} : _temp;\n    Object.defineProperty(this, _apply, {\n      value: _apply2\n    });\n    Object.defineProperty(this, _onMissingKey, {\n      writable: true,\n      value: void 0\n    });\n    this.locale = {\n      strings: {},\n      pluralize(n) {\n        if (n === 1) {\n          return 0;\n        }\n        return 1;\n      }\n    };\n    if (Array.isArray(locales)) {\n      locales.forEach(_classPrivateFieldLooseBase(this, _apply)[_apply], this);\n    } else {\n      _classPrivateFieldLooseBase(this, _apply)[_apply](locales);\n    }\n    _classPrivateFieldLooseBase(this, _onMissingKey)[_onMissingKey] = onMissingKey;\n  }\n  /**\n   * Public translate method\n   *\n   * @param key\n   * @param options with values that will be used later to replace placeholders in string\n   * @returns string translated (and interpolated)\n   */\n  translate(key, options) {\n    return this.translateArray(key, options).join('');\n  }\n\n  /**\n   * Get a translation and return the translated and interpolated parts as an array.\n   *\n   * @returns The translated and interpolated parts, in order.\n   */\n  translateArray(key, options) {\n    let string = this.locale.strings[key];\n    if (string == null) {\n      _classPrivateFieldLooseBase(this, _onMissingKey)[_onMissingKey](key);\n      string = key;\n    }\n    const hasPluralForms = typeof string === 'object';\n    if (hasPluralForms) {\n      if (options && typeof options.smart_count !== 'undefined') {\n        const plural = this.locale.pluralize(options.smart_count);\n        return interpolate(string[plural], options);\n      }\n      throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}');\n    }\n    if (typeof string !== 'string') {\n      throw new Error(`string was not a string`);\n    }\n    return interpolate(string, options);\n  }\n}\nfunction _apply2(locale) {\n  if (!(locale != null && locale.strings)) {\n    return;\n  }\n  const prevLocale = this.locale;\n  Object.assign(this.locale, {\n    strings: {\n      ...prevLocale.strings,\n      ...locale.strings\n    },\n    pluralize: locale.pluralize || prevLocale.pluralize\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}