{"ast":null,"code":"import getFileType from '@uppy/utils/lib/getFileType';\nimport isPreviewSupported from '@uppy/utils/lib/isPreviewSupported';\nimport remoteFileObjToLocal from '@uppy/utils/lib/remoteFileObjToLocal';\n\n// Conditional type for selecting the plugin\n\n// Conditional type for selecting the provider from the selected plugin\n\nexport default class View {\n  constructor(plugin, opts) {\n    this.filterItems = items => {\n      const state = this.plugin.getPluginState();\n      if (!state.filterInput || state.filterInput === '') {\n        return items;\n      }\n      return items.filter(folder => {\n        return folder.name.toLowerCase().indexOf(state.filterInput.toLowerCase()) !== -1;\n      });\n    };\n    this.recordShiftKeyPress = e => {\n      this.isShiftKeyPressed = e.shiftKey;\n    };\n    this.isChecked = file => {\n      const {\n        currentSelection\n      } = this.plugin.getPluginState();\n      // comparing id instead of the file object, because the reference to the object\n      // changes when we switch folders, and the file list is updated\n      return currentSelection.some(item => item.id === file.id);\n    };\n    this.plugin = plugin;\n    this.provider = opts.provider;\n    this.opts = opts;\n    this.isHandlingScroll = false;\n    this.preFirstRender = this.preFirstRender.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.clearSelection = this.clearSelection.bind(this);\n    this.cancelPicking = this.cancelPicking.bind(this);\n  }\n  preFirstRender() {\n    this.plugin.setPluginState({\n      didFirstRender: true\n    });\n    this.plugin.onFirstRender();\n  }\n  shouldHandleScroll(event) {\n    const {\n      scrollHeight,\n      scrollTop,\n      offsetHeight\n    } = event.target;\n    const scrollPosition = scrollHeight - (scrollTop + offsetHeight);\n    return scrollPosition < 50 && !this.isHandlingScroll;\n  }\n  clearSelection() {\n    this.plugin.setPluginState({\n      currentSelection: [],\n      filterInput: ''\n    });\n  }\n  cancelPicking() {\n    this.clearSelection();\n    const dashboard = this.plugin.uppy.getPlugin('Dashboard');\n    if (dashboard) {\n      // @ts-expect-error impossible to type this correctly without adding dashboard\n      // as a dependency to this package.\n      dashboard.hideAllPanels();\n    }\n  }\n  handleError(error) {\n    var _error$cause;\n    const {\n      uppy\n    } = this.plugin;\n    const message = uppy.i18n('companionError');\n    uppy.log(error.toString());\n    if (error.isAuthError || ((_error$cause = error.cause) == null ? void 0 : _error$cause.name) === 'AbortError') {\n      // authError just means we're not authenticated, don't show to user\n      // AbortError means the user has clicked \"cancel\" on an operation\n      return;\n    }\n    uppy.info({\n      message,\n      details: error.toString()\n    }, 'error', 5000);\n  }\n  registerRequestClient() {\n    this.requestClientId = this.provider.provider;\n    this.plugin.uppy.registerRequestClient(this.requestClientId, this.provider);\n  }\n\n  // TODO: document what is a \"tagFile\" or get rid of this concept\n  getTagFile(file) {\n    const tagFile = {\n      id: file.id,\n      source: this.plugin.id,\n      name: file.name || file.id,\n      type: file.mimeType,\n      isRemote: true,\n      data: file,\n      // @ts-expect-error meta is filled conditionally below\n      meta: {},\n      body: {\n        fileId: file.id\n      },\n      remote: {\n        companionUrl: this.plugin.opts.companionUrl,\n        // @ts-expect-error untyped for now\n        url: `${this.provider.fileUrl(file.requestPath)}`,\n        body: {\n          fileId: file.id\n        },\n        providerName: this.provider.name,\n        provider: this.provider.provider,\n        requestClientId: this.requestClientId\n      }\n    };\n    const fileType = getFileType(tagFile);\n\n    // TODO Should we just always use the thumbnail URL if it exists?\n    if (fileType && isPreviewSupported(fileType)) {\n      tagFile.preview = file.thumbnail;\n    }\n    if (file.author) {\n      if (file.author.name != null) tagFile.meta.authorName = String(file.author.name);\n      if (file.author.url) tagFile.meta.authorUrl = file.author.url;\n    }\n\n    // add relativePath similar to non-remote files: https://github.com/transloadit/uppy/pull/4486#issuecomment-1579203717\n    if (file.relDirPath != null) tagFile.meta.relativePath = file.relDirPath ? `${file.relDirPath}/${tagFile.name}` : null;\n    // and absolutePath (with leading slash) https://github.com/transloadit/uppy/pull/4537#issuecomment-1614236655\n    if (file.absDirPath != null) tagFile.meta.absolutePath = file.absDirPath ? `/${file.absDirPath}/${tagFile.name}` : `/${tagFile.name}`;\n    return tagFile;\n  }\n  /**\n   * Toggles file/folder checkbox to on/off state while updating files list.\n   *\n   * Note that some extra complexity comes from supporting shift+click to\n   * toggle multiple checkboxes at once, which is done by getting all files\n   * in between last checked file and current one.\n   */\n  toggleCheckbox(e, file) {\n    e.stopPropagation();\n    e.preventDefault();\n    e.currentTarget.focus();\n    const {\n      folders,\n      files\n    } = this.plugin.getPluginState();\n    const items = this.filterItems(folders.concat(files));\n    // Shift-clicking selects a single consecutive list of items\n    // starting at the previous click.\n    if (this.lastCheckbox && this.isShiftKeyPressed) {\n      const {\n        currentSelection\n      } = this.plugin.getPluginState();\n      const prevIndex = items.indexOf(this.lastCheckbox);\n      const currentIndex = items.indexOf(file);\n      const newSelection = prevIndex < currentIndex ? items.slice(prevIndex, currentIndex + 1) : items.slice(currentIndex, prevIndex + 1);\n      const reducedNewSelection = [];\n\n      // Check restrictions on each file in currentSelection,\n      // reduce it to only contain files that pass restrictions\n      for (const item of newSelection) {\n        const {\n          uppy\n        } = this.plugin;\n        const restrictionError = uppy.validateRestrictions(remoteFileObjToLocal(item), [...uppy.getFiles(), ...reducedNewSelection]);\n        if (!restrictionError) {\n          reducedNewSelection.push(item);\n        } else {\n          uppy.info({\n            message: restrictionError.message\n          }, 'error', uppy.opts.infoTimeout);\n        }\n      }\n      this.plugin.setPluginState({\n        currentSelection: [...new Set([...currentSelection, ...reducedNewSelection])]\n      });\n      return;\n    }\n    this.lastCheckbox = file;\n    const {\n      currentSelection\n    } = this.plugin.getPluginState();\n    if (this.isChecked(file)) {\n      this.plugin.setPluginState({\n        currentSelection: currentSelection.filter(item => item.id !== file.id)\n      });\n    } else {\n      this.plugin.setPluginState({\n        currentSelection: currentSelection.concat([file])\n      });\n    }\n  }\n  setLoading(loading) {\n    this.plugin.setPluginState({\n      loading\n    });\n  }\n}","map":{"version":3,"names":["getFileType","isPreviewSupported","remoteFileObjToLocal","View","constructor","plugin","opts","filterItems","items","state","getPluginState","filterInput","filter","folder","name","toLowerCase","indexOf","recordShiftKeyPress","e","isShiftKeyPressed","shiftKey","isChecked","file","currentSelection","some","item","id","provider","isHandlingScroll","preFirstRender","bind","handleError","clearSelection","cancelPicking","setPluginState","didFirstRender","onFirstRender","shouldHandleScroll","event","scrollHeight","scrollTop","offsetHeight","target","scrollPosition","dashboard","uppy","getPlugin","hideAllPanels","error","_error$cause","message","i18n","log","toString","isAuthError","cause","info","details","registerRequestClient","requestClientId","getTagFile","tagFile","source","type","mimeType","isRemote","data","meta","body","fileId","remote","companionUrl","url","fileUrl","requestPath","providerName","fileType","preview","thumbnail","author","authorName","String","authorUrl","relDirPath","relativePath","absDirPath","absolutePath","toggleCheckbox","stopPropagation","preventDefault","currentTarget","focus","folders","files","concat","lastCheckbox","prevIndex","currentIndex","newSelection","slice","reducedNewSelection","restrictionError","validateRestrictions","getFiles","push","infoTimeout","Set","setLoading","loading"],"sources":["/home/nainar/Documents/reactProjects/userAuthentiCator/registeration-login/node_modules/@uppy/provider-views/lib/View.js"],"sourcesContent":["import getFileType from '@uppy/utils/lib/getFileType';\nimport isPreviewSupported from '@uppy/utils/lib/isPreviewSupported';\nimport remoteFileObjToLocal from '@uppy/utils/lib/remoteFileObjToLocal';\n\n// Conditional type for selecting the plugin\n\n// Conditional type for selecting the provider from the selected plugin\n\nexport default class View {\n  constructor(plugin, opts) {\n    this.filterItems = items => {\n      const state = this.plugin.getPluginState();\n      if (!state.filterInput || state.filterInput === '') {\n        return items;\n      }\n      return items.filter(folder => {\n        return folder.name.toLowerCase().indexOf(state.filterInput.toLowerCase()) !== -1;\n      });\n    };\n    this.recordShiftKeyPress = e => {\n      this.isShiftKeyPressed = e.shiftKey;\n    };\n    this.isChecked = file => {\n      const {\n        currentSelection\n      } = this.plugin.getPluginState();\n      // comparing id instead of the file object, because the reference to the object\n      // changes when we switch folders, and the file list is updated\n      return currentSelection.some(item => item.id === file.id);\n    };\n    this.plugin = plugin;\n    this.provider = opts.provider;\n    this.opts = opts;\n    this.isHandlingScroll = false;\n    this.preFirstRender = this.preFirstRender.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.clearSelection = this.clearSelection.bind(this);\n    this.cancelPicking = this.cancelPicking.bind(this);\n  }\n  preFirstRender() {\n    this.plugin.setPluginState({\n      didFirstRender: true\n    });\n    this.plugin.onFirstRender();\n  }\n  shouldHandleScroll(event) {\n    const {\n      scrollHeight,\n      scrollTop,\n      offsetHeight\n    } = event.target;\n    const scrollPosition = scrollHeight - (scrollTop + offsetHeight);\n    return scrollPosition < 50 && !this.isHandlingScroll;\n  }\n  clearSelection() {\n    this.plugin.setPluginState({\n      currentSelection: [],\n      filterInput: ''\n    });\n  }\n  cancelPicking() {\n    this.clearSelection();\n    const dashboard = this.plugin.uppy.getPlugin('Dashboard');\n    if (dashboard) {\n      // @ts-expect-error impossible to type this correctly without adding dashboard\n      // as a dependency to this package.\n      dashboard.hideAllPanels();\n    }\n  }\n  handleError(error) {\n    var _error$cause;\n    const {\n      uppy\n    } = this.plugin;\n    const message = uppy.i18n('companionError');\n    uppy.log(error.toString());\n    if (error.isAuthError || ((_error$cause = error.cause) == null ? void 0 : _error$cause.name) === 'AbortError') {\n      // authError just means we're not authenticated, don't show to user\n      // AbortError means the user has clicked \"cancel\" on an operation\n      return;\n    }\n    uppy.info({\n      message,\n      details: error.toString()\n    }, 'error', 5000);\n  }\n  registerRequestClient() {\n    this.requestClientId = this.provider.provider;\n    this.plugin.uppy.registerRequestClient(this.requestClientId, this.provider);\n  }\n\n  // TODO: document what is a \"tagFile\" or get rid of this concept\n  getTagFile(file) {\n    const tagFile = {\n      id: file.id,\n      source: this.plugin.id,\n      name: file.name || file.id,\n      type: file.mimeType,\n      isRemote: true,\n      data: file,\n      // @ts-expect-error meta is filled conditionally below\n      meta: {},\n      body: {\n        fileId: file.id\n      },\n      remote: {\n        companionUrl: this.plugin.opts.companionUrl,\n        // @ts-expect-error untyped for now\n        url: `${this.provider.fileUrl(file.requestPath)}`,\n        body: {\n          fileId: file.id\n        },\n        providerName: this.provider.name,\n        provider: this.provider.provider,\n        requestClientId: this.requestClientId\n      }\n    };\n    const fileType = getFileType(tagFile);\n\n    // TODO Should we just always use the thumbnail URL if it exists?\n    if (fileType && isPreviewSupported(fileType)) {\n      tagFile.preview = file.thumbnail;\n    }\n    if (file.author) {\n      if (file.author.name != null) tagFile.meta.authorName = String(file.author.name);\n      if (file.author.url) tagFile.meta.authorUrl = file.author.url;\n    }\n\n    // add relativePath similar to non-remote files: https://github.com/transloadit/uppy/pull/4486#issuecomment-1579203717\n    if (file.relDirPath != null) tagFile.meta.relativePath = file.relDirPath ? `${file.relDirPath}/${tagFile.name}` : null;\n    // and absolutePath (with leading slash) https://github.com/transloadit/uppy/pull/4537#issuecomment-1614236655\n    if (file.absDirPath != null) tagFile.meta.absolutePath = file.absDirPath ? `/${file.absDirPath}/${tagFile.name}` : `/${tagFile.name}`;\n    return tagFile;\n  }\n  /**\n   * Toggles file/folder checkbox to on/off state while updating files list.\n   *\n   * Note that some extra complexity comes from supporting shift+click to\n   * toggle multiple checkboxes at once, which is done by getting all files\n   * in between last checked file and current one.\n   */\n  toggleCheckbox(e, file) {\n    e.stopPropagation();\n    e.preventDefault();\n    e.currentTarget.focus();\n    const {\n      folders,\n      files\n    } = this.plugin.getPluginState();\n    const items = this.filterItems(folders.concat(files));\n    // Shift-clicking selects a single consecutive list of items\n    // starting at the previous click.\n    if (this.lastCheckbox && this.isShiftKeyPressed) {\n      const {\n        currentSelection\n      } = this.plugin.getPluginState();\n      const prevIndex = items.indexOf(this.lastCheckbox);\n      const currentIndex = items.indexOf(file);\n      const newSelection = prevIndex < currentIndex ? items.slice(prevIndex, currentIndex + 1) : items.slice(currentIndex, prevIndex + 1);\n      const reducedNewSelection = [];\n\n      // Check restrictions on each file in currentSelection,\n      // reduce it to only contain files that pass restrictions\n      for (const item of newSelection) {\n        const {\n          uppy\n        } = this.plugin;\n        const restrictionError = uppy.validateRestrictions(remoteFileObjToLocal(item), [...uppy.getFiles(), ...reducedNewSelection]);\n        if (!restrictionError) {\n          reducedNewSelection.push(item);\n        } else {\n          uppy.info({\n            message: restrictionError.message\n          }, 'error', uppy.opts.infoTimeout);\n        }\n      }\n      this.plugin.setPluginState({\n        currentSelection: [...new Set([...currentSelection, ...reducedNewSelection])]\n      });\n      return;\n    }\n    this.lastCheckbox = file;\n    const {\n      currentSelection\n    } = this.plugin.getPluginState();\n    if (this.isChecked(file)) {\n      this.plugin.setPluginState({\n        currentSelection: currentSelection.filter(item => item.id !== file.id)\n      });\n    } else {\n      this.plugin.setPluginState({\n        currentSelection: currentSelection.concat([file])\n      });\n    }\n  }\n  setLoading(loading) {\n    this.plugin.setPluginState({\n      loading\n    });\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}